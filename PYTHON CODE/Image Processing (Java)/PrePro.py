import cv2
import numpy as np
import math
import os

class PrePro:
    # Constants
    SMALL_REGION_REMOVAL_THRESHOLD = 100
    OPEN_SMALL_REGION_REMOVAL = 50
    ARROW_OPEN_RADIUS = 10
    HOUGH_THRESHOLD = 50
    HOUGH_MIN_LINE_LENGTH = 30
    HOUGH_MAX_LINE_GAP = 5
    CANNY_THRESHOLD_1 = 100
    CANNY_THRESHOLD_2 = 100
    CANNY_APETURE_SIZE = 3

    @staticmethod
    def prepro(mat):
        try:
            print("Hello, World!")

            # Get image dimensions
            rows, cols = mat.shape[:2]

            # Convert to grayscale
            gray = cv2.cvtColor(mat, cv2.COLOR_RGB2GRAY)
            print("Grayscale Done!")
            PrePro.saveImage(gray, "gray")

            # Adaptive thresholding (binarization)
            bina = cv2.adaptiveThreshold(gray, 255, cv2.ADAPTIVE_THRESH_MEAN_C,
                                         cv2.THRESH_BINARY, 65, 40)
            print("Binarization Done!")
            PrePro.saveImage(bina, "bina")

            # Bitwise inversion
            bina = cv2.bitwise_not(bina)
            print("BitWiseNot Done!")
            PrePro.saveImage(bina, "invt")

            # Denoise and fill
            denoise = PrePro.denoiseAndFill(bina, PrePro.SMALL_REGION_REMOVAL_THRESHOLD)
            PrePro.saveImage(denoise, "denoise")

            # Edge detection
            edges = cv2.Canny(denoise, PrePro.CANNY_THRESHOLD_1, PrePro.CANNY_THRESHOLD_2,
                              apertureSize=PrePro.CANNY_APETURE_SIZE, L2gradient=False)
            print("GetEdge Done!")

            # Hough Transform
            lines = cv2.HoughLinesP(edges, 1, np.pi / 180.0, PrePro.HOUGH_THRESHOLD,
                                    minLineLength=PrePro.HOUGH_MIN_LINE_LENGTH,
                                    maxLineGap=PrePro.HOUGH_MAX_LINE_GAP)
            # Rotate image if lines are detected
            if lines is not None and len(lines) > 0:
                rotated = PrePro.rotate(denoise, lines)
                substitute = rotated.copy()
                rows, cols = substitute.shape[:2]
            else:
                substitute = denoise.copy()
            PrePro.saveImage(substitute, "subs")

            # Fill small regions
            smallRegion = 100
            fill = PrePro.denoiseAndFill(substitute, smallRegion)

            # Morphological opening to eliminate arrows
            seOpen = PrePro.seGen(PrePro.ARROW_OPEN_RADIUS)
            opened = cv2.morphologyEx(fill, cv2.MORPH_OPEN, seOpen)
            print("Open Done!")
            PrePro.saveImage(opened, "open")

            # Denoise and fill again
            opened = PrePro.denoiseAndFill(opened, smallRegion)

            # Compute difference to get arrows
            diff = cv2.absdiff(fill, opened)
            print("Diff Done!")

            # Remove small areas generated by opening
            remv = PrePro.denoiseAndFill(diff, PrePro.OPEN_SMALL_REGION_REMOVAL)
            PrePro.saveImage(remv, "remv")

            # Dilate to enhance arrows
            arro = PrePro.dilate(remv, 10)
            PrePro.saveImage(arro, "dilated")

            # Extract rectangles and diamonds
            blob = cv2.absdiff(fill, remv)
            print("Blob Done!")
            PrePro.saveImage(fill, "fill")

            # Find circles
            eroded_blob = PrePro.erode(blob, 10)
            diff_blob = cv2.absdiff(blob, eroded_blob)
            copy_blob = diff_blob.copy()
            PrePro.saveImage(diff_blob, "diff_blob")

            contours, _ = cv2.findContours(diff_blob, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)
            for contour in contours:
                temp = np.zeros_like(diff_blob)
                cv2.drawContours(temp, [contour], -1, 255, 10)
                circles = cv2.HoughCircles(temp, cv2.HOUGH_GRADIENT, 2,
                                           substitute.shape[0]/4, param1=200,
                                           param2=100, minRadius=0, maxRadius=0)
                if circles is not None and len(circles) > 0:
                    print("aha")
                    cv2.fillPoly(copy_blob, [contour], 0)
            circ = cv2.absdiff(diff_blob, copy_blob)
            PrePro.saveImage(copy_blob, "copy_blob")

            # Distinguish rectangles and diamonds
            rect, diam = PrePro.genRectAndDiam(copy_blob)

            # Erode
            eroded_rect = PrePro.erode(rect, 10)
            eroded_diam = PrePro.erode(diam, 10)
            PrePro.saveImage(eroded_rect, "eroded_rect")
            PrePro.saveImage(eroded_diam, "eroded_diam")

            # Get final rectangles and diamonds
            rect = cv2.absdiff(rect, eroded_rect)
            diam = cv2.absdiff(diam, eroded_diam)
            print("Box Done!")

            # Prepare result
            result = [rect, diam, arro, circ]
            print("Conversion Done!")
            return result

        except Exception as e:
            print("Error:", e)
            return None

    # Helper methods converted to Python
    @staticmethod
    def denoiseAndFill(m, thres):
        contours, _ = cv2.findContours(m, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)
        denoise = np.zeros_like(m)
        for contour in contours:
            if cv2.contourArea(contour) > thres:
                cv2.drawContours(denoise, [contour], -1, 255, thickness=cv2.FILLED)
        print("Denoise Done!")
        return denoise

    @staticmethod
    def rotate(m, lines):
        angles = []
        for line in lines:
            for x1, y1, x2, y2 in line:
                angle = math.atan2(y2 - y1, x2 - x1)
                angles.append(angle)
        angles.sort()
        majority_angles = PrePro.findMajority(np.array(angles), 10)
        angle = np.median(majority_angles)
        degree = math.degrees(angle)

        # Rotate image
        (h, w) = m.shape[:2]
        center = (w // 2, h // 2)
        rotMat = cv2.getRotationMatrix2D(center, degree, 1.0)
        rotated = cv2.warpAffine(m, rotMat, (w, h), flags=cv2.INTER_LINEAR)
        print("Rotation Done!")
        return rotated

    @staticmethod
    def findMajority(input_angles, splits):
        pi = math.pi
        bins = np.linspace(-pi/2, pi/2, splits+1)
        hist, bin_edges = np.histogram(input_angles, bins)
        max_bin = np.argmax(hist)
        mask = (input_angles >= bin_edges[max_bin]) & (input_angles < bin_edges[max_bin+1])
        majority = input_angles[mask]
        return majority

    @staticmethod
    def dilate(m, r):
        se = PrePro.seGen(r)
        dilated = cv2.dilate(m, se)
        print("Dilate Done!")
        return dilated

    @staticmethod
    def erode(m, r):
        se = PrePro.seGen(r)
        eroded = cv2.erode(m, se)
        print("Erode Done!")
        return eroded

    @staticmethod
    def seGen(radius):
        diameter = 2 * radius + 1
        se = cv2.getStructuringElement(cv2.MORPH_ELLIPSE, (diameter, diameter))
        return se

    @staticmethod
    def genRectAndDiam(m):
        contours, _ = cv2.findContours(m, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)
        rectangle = np.zeros_like(m)
        diamond = np.zeros_like(m)
        for contour in contours:
            area = cv2.contourArea(contour)
            x, y, w, h = cv2.boundingRect(contour)
            rect_area = w * h
            if area / rect_area > 0.75:
                cv2.drawContours(rectangle, [contour], -1, 255, thickness=cv2.FILLED)
            else:
                cv2.drawContours(diamond, [contour], -1, 255, thickness=cv2.FILLED)
        print("Rectangle Diamond Done!")
        return rectangle, diamond

    @staticmethod
    def saveImage(mat, fileName):
        # Save image to file
        cv2.imwrite(os.path.join("/Users/zhangrao/Desktop/", fileName + ".png"), mat)
